Easing Curves: https://easings.net/

THINGS TO DO - Pro Version: 
- Auto-Exit Timer, Ping Pong
- Delay per element also has to be per properties
- Delay for each element
- Exclude Button Text in Position and Rotation option -> Will need the script to remember which one is a child object
- Interruptible Fade In/Out Animation -> Will require a rewrite where there will only be one timer for every animation 
- UI Timeline for easy visualization
- TextMeshPro kerning option, where the letters expand in length

FUTURE FEATURES
- For the text-altering, we need some shader and masking
- Emphasis (Effects over lifetime, with automatic fade out timer)

List of Scriptable Objects:
- Appear (no animation at all)
- Disappear (no animation at all)
- Fly in from left (without smoothing)
- Fly in from right (without smoothing)
- Fly in from top (without smoothing)
- Fly in from bottom (without smoothing)
- Smooth fly in from left
- Smooth fly in from right (without smoothing)
- Smooth fly in from top (without smoothing)
- Smooth fly in from bottom (without smoothing)
- Overshoot fly in from left (the curve is over the field)
- Overshoot fly in from right (the curve is over the field)
- Overshoot fly in from top (the curve is over the field)
- Overshoot fly in from bottom (the curve is over the field)
- Zoom in (from smaller to big)
- Zoom out (from big to smaller)
- Smooth Zoom in 
- Smooth Zoom out
- Overshoot zoom in
- Overshoot zoom out
- Stretch horizontally (only on X axis)
- Stretch vertically (only on X axis)
- Smooth Stretch Horizontally
- Overshoot stretch horizontally





private IEnumerator EntranceAlphaEnumeration()
    {
        if (componentList.Count > 0 && animationEntrancePresets.useAlphaAnimation == true)
        {
            SetAllColorAlpha_Zero();
            float[] delayTimer = CalculateDelayTimer(DelayTimerType.TopToBottom, animationEntrancePresets);
            float[] elapsedTime = new float[componentList.Count];

            /// Animate the fade in animation
            while (elapsedTime[componentList.Count - 1] < animationEntrancePresets.alphaDuration)
            {
                for (int i = 0; i < componentList.Count; i++)
                {
                    //Don't do anything when the animation for this item is already finished.
                    if (elapsedTime[i] >= animationEntrancePresets.alphaDuration)
                    {
                        //Set its final state
                        SetColorAlpha(componentList[i], originalAlpha[i]);
                        continue;
                    }

                    //Don't do anything until the delay timer reaches 0
                    if (delayTimer[i] > 0f)
                    {
                        delayTimer[i] -= Time.deltaTime;
                        continue;
                    }


                    //Count the interpolated value from the animation curve
                    float t = elapsedTime[i] / animationEntrancePresets.alphaDuration;

                    //Calculate current alpha
                    float curveValue = animationEntrancePresets.curveAlpha.Evaluate(t);
                    float currentAlpha = Mathf.Lerp(0, originalAlpha[i], curveValue);
                    SetColorAlpha(componentList[i], currentAlpha);

                    elapsedTime[i] += Time.deltaTime;
                }
                yield return null;
            }
        }

        //There are always inaccuracies when dealing with float values
        //So to keep it safe, when the final loop is done, set everything to its final state.
        SetAllColorAlpha_Original();
    }


private IEnumerator ExitAlphaEnumeration()
    {
        if (componentList.Count > 0 && animationExitPresets.useAlphaAnimation == true)
        {
            /// Set starting state where the UI is invisible
            SetAllColorAlpha_Original();
            float[] delayTimer = CalculateDelayTimer(DelayTimerType.BottomToTop, animationExitPresets);
            float[] elapsedTime = new float[componentList.Count];

            /// Animate the fade out animation
            while (elapsedTime[0] < animationExitPresets.alphaDuration)
            {
                for (int i = 0; i < componentList.Count; i++)
                {
                    //Don't do anything when the animation for this item is already finished.
                    if (elapsedTime[i] > animationExitPresets.alphaDuration)
                    {
                        //Set its final state
                        SetColorAlpha(componentList[i], 0);
                        continue;
                    }

                    //Don't do anything until the delay timer reaches 0
                    if (delayTimer[i] > 0f)
                    {
                        delayTimer[i] -= Time.deltaTime;
                        continue;
                    }

                    //Count the interpolated value from the animation curve
                    float t = elapsedTime[i] / animationExitPresets.alphaDuration;

                    //Calculate current alpha
                    float curveValue = animationEntrancePresets.curveAlpha.Evaluate(t);
                    float currentAlpha = Mathf.Lerp(originalAlpha[i], 0, curveValue);
                    SetColorAlpha(componentList[i], currentAlpha);

                    elapsedTime[i] += Time.deltaTime;
                }
                yield return null;
            }
        }

        //There are always inaccuracies when dealing with float values
        //So to keep it safe, when the final loop is done, set everything to its final state.
        SetAllColorAlpha_Zero();
    }

private void SetColorAlpha(Component component, float value)
    {
        if (component is TextMeshProUGUI)
        {
            float alpha = value;
            ((TextMeshProUGUI)component).alpha = alpha;
        }
        else if (component is Image)
        {
            float alpha = value;
            Color imageColor = ((Image)component).color;
            imageColor.a = alpha;
            ((Image)component).color = imageColor;
        }
    }

private void SetAllColorAlpha_Original()
    {
        if (componentList.Count > 0)
        {
            for (int i = 0; i < componentList.Count; i++)
            {
                SetColorAlpha(componentList[i], originalAlpha[i]);
            }
        }
    }

private void SetAllColorAlpha_Zero()
    {
        if (componentList.Count > 0)
        {
            for (int i = 0; i < componentList.Count; i++)
            {
                SetColorAlpha(componentList[i], 0);
            }
        }
    }